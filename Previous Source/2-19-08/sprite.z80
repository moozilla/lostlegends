;SpriteMov
;by Jason Lee (Liazon)
;========================================
;a = keyinput results from the keyget routine
SpriteMov:
	bit b_down,a
	jp z,SpriteMov_down
	bit b_up,a
	jp z,SpriteMov_up 
	bit b_left,a
	jp z,SpriteMov_left
SpriteMov_right:
	ld bc,(px)			;c has px, b has py
	ld a,c				;check if current tile is at edge
	inc c				;tile to right
	cp 5				;check if it'a already at the edge
	jp nz,SpriteMov_right_norm
	;CODE GOES HERE FOR WHERE A SCREEN SHIFT IS NEEDED
SpriteMov_right_norm:
	ld d,0
	ld a,6
	ld e,b
	call DExA			;y tile * 6 
	add hl,bc			;hl is the offset in the tile array
	ld de,NBmap			;looking at current map
	add hl,de			;hl points to tile in the right
	bit impabit,(hl)	;see if the impassable bit is set
	jr nz,SpriteMov_right_norm2
	ld a,c
	ld (px),a			;passable, so update the coordinates
	ld b,4				;4 part animation
SpriteMov_right_norm2:

SpriteMov_left:
SpriteMov_up:
SpriteMov_down:
	

;gs16masked
;by Jason Lee (Liazon)
;========================================
;ix = sprite mask pointer
;a = x
;l = y
;b = height
;gstempsprite = used for scrolling storage
;gstempsprite + 1 = sprite pointer
;uses ASMFlag1 bit 1
;sprites arranged like so
;dark layer
;light layer
;mask layer
;DESTROYS VIRTUALLY EVERYTHING!
;=========================================
;might modify later to calculate location of mask based on height
gs16masked:
	set gs16maskedflag,(iy + mygfxflags)
	ld e,l			;l and e have "y"
	ld h,0
	ld d,h
	add hl,de		;*2
	add hl,de		;*3	
	add hl,hl		;*6
	add hl,hl		;*12	
	ld e,a
	and $07			;a holds the number of bits to shift
	ld (gs16maskedwidth),a			;save number of bits to shift in temp RAM
	srl e			;/2
	srl e			;/4
	srl e			;/8
	add hl,de		;hl = y*12; de = x rounded <- add to get screenbuffer offset
	ex de,hl
	ld hl,gbuf2	
	add hl,de		;address on light layer
	push bc			;save the height for second round
	push hl			;save light layer address for second round (sprite not mask)
	ld hl,gbuf1
	add hl,de
	push bc
	push hl
gs16masked_L1:
	push hl			;save dark layer address
	ld de,gbuf2-gbuf1
	add hl,de		;dark layer address
		ld d,(ix)	;using massive dec register
		inc ix
		ld e,(ix)
		ld c,$FF		;zero out b for AND LOGIC!!!
		ld a,(gs16maskedwidth)
		or a		;cp 0
		jr z,gs16masked_DMask
		scf			;set carry
gs16masked_shiftMask:
		rr d		;shifting to the right -> destroyed bit goes into carry
		rr e		;shifting to the right -> destroyed bit goes into carry
		rr c		;shifting to the right
		dec a
		jr nz, gs16masked_shiftMask
gs16masked_DMask:	;AND LOGIC!!!!
        ld   a,(hl)   ;graphbyte in a (DARK LAYER)
        and   d      ;AND first byte
        ld   (hl),a   ;back to buffer
        inc   hl      ;increase pointer
        ld   a,(hl)   ;graphbyte in a
        and   e      ;AND second byte
        ld   (hl),a   ;back to buffer
		inc hl
		ld a,(hl)
		and c
		ld (hl),a
		pop hl			;repeat for light layer
		ld   a,(hl)   ;graphbyte in a (LIGHT LAYER)
        and   d      ;AND first byte
        ld   (hl),a   ;back to buffer
        inc   hl      ;increase pointer
        ld   a,(hl)   ;graphbyte in a
        and   e      ;AND second byte
        ld   (hl),a   ;back to buffer
		inc hl
		ld a,(hl)
		and c
		ld (hl),a
        inc   ix      ;increase sprite adress
		ld de,10		
		add hl,de		;next row of light layer
	djnz gs16masked_L1
	ld ix,(gs16maskedsprite)		;give ix the pointer to the sprite
gs16masked_L3:
	pop hl
	pop bc
gs16masked_L2:
		ld d,(ix)	;using massive dec register
		inc ix
		ld e,(ix)
		ld c,$00		;zero out c for XOR LOGIC!!!
		ld a,(gs16maskedwidth)
		or a		;cp 0
		jr z,gs16masked_DMask2
gs16masked_shiftMask2:
		srl d		;shifting to the right -> destroyed bit goes into carry
		rr e		;shifting to the right -> destroyed bit goes into carry
		rr c		;shifting to the right
		dec a
		jr nz, gs16masked_shiftMask2
gs16masked_DMask2:	;XOR LOGIC!!!!
        ld   a,(hl)   ;graphbyte in a (DARK LAYER)
        XOR   d      ;XOR first byte
        ld   (hl),a   ;back to buffer
        inc   hl      ;increase pointer
        ld   a,(hl)   ;graphbyte in a
        XOR   e      ;XOR second byte
        ld   (hl),a   ;back to buffer
		inc hl
		ld a,(hl)
		XOR c
		ld (hl),a
        inc   ix      ;increase sprite adress
		ld de,10		;12
		add hl,de		;next row of light layer
	djnz gs16masked_L2
	bit gs16maskedflag,(iy + mygfxflags)
	jr z,gs16masked_exit
	res gs16maskedflag,(iy + mygfxflags)
	jr gs16masked_L3
gs16masked_exit:
	ret

;sprites currently arranged down, up, right, left w/ animation 1 followed by animation 2	
#include "charsprite.inc"
