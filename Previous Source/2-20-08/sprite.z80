;NSpriteMov
;by Jason Lee (Liazon)
;========================================
;a = keyinput results from the keyget routine
NSpriteMov:
	ld de,(ctile)	;load the address to the current tile to de
	ld bc,(py)		;c = py, b = px
	sla b \ sla b \ sla b \ sla b		;*x16 gets pixel coordinates
	sla c \ sla c \ sla c \ sla c		;*x16 gets pixel coordinates
	bit b_right,a
	jr nz,NSpriteMov_right_skip
	ld hl,charright
	ld a,(px)
	cp 5				;check if current x tile # is 5
	jp z,NSpriteMov_right_shift		;go to a block of code that handles shifting the plane
	inc de				;de points to tile to right
	ex de,hl			;switch the two
	bit impabit,(hl)
	jp nz,NSpriteMov_Hori_Zero
	inc a
	ld (px),a			;update px permanently
	ld (ctile),hl		;update current tile permanently
	ld a,aniDelta			;4 PART ANIMATION, animation delta
	jp NSpriteMov_Hori
NSpriteMov_Hori_Zero:
	xor a			;zero delta
	jp NSpriteMov_Hori
NSpriteMov_right_skip:
	bit b_left,a
	jp nz,NSpriteMov_left_skip
	ld hl,charleft
	ld a,(px)
	cp 0				;check if current x # tile is 5
	jp z,NSpriteMov_left_shift			;go to a block to handle plane shifts
	dec de				;de points to tile to left
	ex de,hl
	bit impabit,(hl)
	jp nz,NSpriteMov_Hori_Zero
	dec a
	ld (px),a
	ld (ctile),hl			;updat px and tile permanently
	ld a,-1*aniDelta
	jp NSpriteMov_Hori
NSpriteMov_left_skip:
	bit b_up,a
	jp nz,NSpriteMov_up_skip
NSpriteMov_up_skip:	
	bit b_down,a
	jp nz,CheckWhatOn
CheckWhatOn:	

NSpriteMov_Hori:
	push bc
	ex de,hl			;hl has sprite start
	ld (sanime1),hl
	ld bc,$0040			;64 between start and mask
	add hl,bc			
	ld (sanime1mask),hl
	sra c				;div by 2 so 32
	add hl,bc
	ld (sanime2),hl
	sla c				;mult by 2, back to 64
	add hl,bc
	ld (sanime2mask),hl
	pop hl				;de has x and y pixel data
	ld c,a
	ld b,numAni				; b = 4 # of animations, c = delta
NSpriteMov_Hori_Loop:
	push bc
	push hl
	call draw6x4map			;clean slate
	pop hl
	pop bc
	push bc
	bit 0,b			;test if odd/even -> even = second sprite
	jr nz,NSpriteMov_Hori_S
	ld ix,(sanime2Mask)
	ld de,(sanime2)
	ld (gs16maskedsprite),de
	jp NSpriteMov_Hori_S2
NSpriteMov_Hori_S:
	ld ix,(sanime1mask)
	ld de,(sanime1)
	ld (gs16maskedsprite),de
NSpriteMov_Hori_S2:
	ld a,h
	add a,c			;increment the x coordinate
	ld h,a
	push hl
	ld b,16		;height
	call gs16masked
	call gscopybuffer
	pop hl
	pop bc
	djnz NSpriteMov_Hori_loop
	ret
	
;a = (px), hl = charright, bc = x,y in pixels, de = (ctile)	
NSpriteMov_right_shift:
	xor a				;zero a
	ld (px),a			;update px permanently
	ld hl,(NBright)		;right node's address
	push bc
	call CalcCtile
	pop bc				;charright got destroyed btw
	
	
	
	
NSpriteMov_left_shift:

;SpriteMov
;by Jason Lee (Liazon)
;========================================
;a = keyinput results from the keyget routine
SpriteMov:
	bit b_down,a
	jp z,SpriteMov_down
	bit b_up,a
	jp z,SpriteMov_up 
	bit b_left,a
	jp z,SpriteMov_left
SpriteMov_right:
	ld bc,(px)			;c has px, b has py
	ld a,c				;check if current tile is at edge
	inc c				;tile to right
	cp 5				;check if it'a already at the edge
	jp nz,SpriteMov_right_norm
	;CODE GOES HERE FOR WHERE A SCREEN SHIFT IS NEEDED
	;for now just
	ret
SpriteMov_right_norm:
	ld d,0
	ld a,6
	ld e,b
	call DExA			;y tile * 6 
	add hl,bc			;hl is the offset in the tile array
	ld de,NBmap			;looking at current map
	add hl,de			;hl points to tile in the right
	bit impabit,(hl)	;see if the impassable bit is set
	ld d,0
	jr nz,SpriteMov_right_norm2
	ld a,c
	ld (px),a			;passable, so update the coordinates permanently
	ld d,4				;amount to move right
SpriteMov_right_norm2:
	ld a,(py)
	sla a \ sla a \ sla a \ sla a	;x16 gets you pixel y coordinate
	ld l,a
	dec c				;look at original tile's x, b should be 0 btw
	sla c \ sla c \ sla c \ sla c	;x16 to get pixel x offset
	ld h,c					;a = x coord, l = y coord
	ld c,d				;c holds amount to move horizontally by during animation
	ld b,4				;4 part animation
SpriteMov_right_loop:
	push bc
	push hl
	call draw6x4map			;clean slate
	pop hl
	pop bc
	push bc
	bit 0,b			;test if odd/even -> even = second sprite
	jr nz,SpriteMov_right_S
	ld ix,charright2 + 64
	ld de,charright2
	ld (gs16maskedsprite),de
	jp SpriteMov_right_S2
SpriteMov_right_S:
	ld ix,charright + 64
	ld de,charright
	ld (gs16maskedsprite),de
SpriteMov_right_S2:
	ld a,h
	add a,c			;increment the x coordinate
	ld h,a
	push hl
	ld b,16		;height
	call gs16masked
	call gscopybuffer
	pop hl
	pop bc
	djnz SpriteMov_right_loop
	ret
SpriteMov_left:
SpriteMov_up:
SpriteMov_down:
	

;gs16masked
;by Jason Lee (Liazon)
;========================================
;ix = sprite mask pointer
;a = x
;l = y
;b = height
;gstempsprite = used for scrolling storage
;gstempsprite + 1 = sprite pointer (gs16maskedsprite)
;uses ASMFlag1 bit 1
;sprites arranged like so
;dark layer
;light layer
;mask layer
;DESTROYS VIRTUALLY EVERYTHING!
;=========================================
;might modify later to calculate location of mask based on height
gs16masked:
	set gs16maskedflag,(iy + mygfxflags)
	ld e,l			;l and e have "y"
	ld h,0
	ld d,h
	add hl,de		;*2
	add hl,de		;*3	
	add hl,hl		;*6
	add hl,hl		;*12	
	ld e,a
	and $07			;a holds the number of bits to shift
	ld (gs16maskedwidth),a			;save number of bits to shift in temp RAM
	srl e			;/2
	srl e			;/4
	srl e			;/8
	add hl,de		;hl = y*12; de = x rounded <- add to get screenbuffer offset
	ex de,hl
	ld hl,gbuf2	
	add hl,de		;address on light layer
	push bc			;save the height for second round
	push hl			;save light layer address for second round (sprite not mask)
	ld hl,gbuf1
	add hl,de
	push bc
	push hl
gs16masked_L1:
	push hl			;save dark layer address
	ld de,gbuf2-gbuf1
	add hl,de		;dark layer address
		ld d,(ix)	;using massive dec register
		inc ix
		ld e,(ix)
		ld c,$FF		;zero out b for AND LOGIC!!!
		ld a,(gs16maskedwidth)
		or a		;cp 0
		jr z,gs16masked_DMask
		scf			;set carry
gs16masked_shiftMask:
		rr d		;shifting to the right -> destroyed bit goes into carry
		rr e		;shifting to the right -> destroyed bit goes into carry
		rr c		;shifting to the right
		dec a
		jr nz, gs16masked_shiftMask
gs16masked_DMask:	;AND LOGIC!!!!
        ld   a,(hl)   ;graphbyte in a (DARK LAYER)
        and   d      ;AND first byte
        ld   (hl),a   ;back to buffer
        inc   hl      ;increase pointer
        ld   a,(hl)   ;graphbyte in a
        and   e      ;AND second byte
        ld   (hl),a   ;back to buffer
		inc hl
		ld a,(hl)
		and c
		ld (hl),a
		pop hl			;repeat for light layer
		ld   a,(hl)   ;graphbyte in a (LIGHT LAYER)
        and   d      ;AND first byte
        ld   (hl),a   ;back to buffer
        inc   hl      ;increase pointer
        ld   a,(hl)   ;graphbyte in a
        and   e      ;AND second byte
        ld   (hl),a   ;back to buffer
		inc hl
		ld a,(hl)
		and c
		ld (hl),a
        inc   ix      ;increase sprite adress
		ld de,10		
		add hl,de		;next row of light layer
	djnz gs16masked_L1
	ld ix,(gs16maskedsprite)		;give ix the pointer to the sprite
gs16masked_L3:
	pop hl
	pop bc
gs16masked_L2:
		ld d,(ix)	;using massive dec register
		inc ix
		ld e,(ix)
		ld c,$00		;zero out c for XOR LOGIC!!!
		ld a,(gs16maskedwidth)
		or a		;cp 0
		jr z,gs16masked_DMask2
gs16masked_shiftMask2:
		srl d		;shifting to the right -> destroyed bit goes into carry
		rr e		;shifting to the right -> destroyed bit goes into carry
		rr c		;shifting to the right
		dec a
		jr nz, gs16masked_shiftMask2
gs16masked_DMask2:	;XOR LOGIC!!!!
        ld   a,(hl)   ;graphbyte in a (DARK LAYER)
        XOR   d      ;XOR first byte
        ld   (hl),a   ;back to buffer
        inc   hl      ;increase pointer
        ld   a,(hl)   ;graphbyte in a
        XOR   e      ;XOR second byte
        ld   (hl),a   ;back to buffer
		inc hl
		ld a,(hl)
		XOR c
		ld (hl),a
        inc   ix      ;increase sprite adress
		ld de,10		;12
		add hl,de		;next row of light layer
	djnz gs16masked_L2
	bit gs16maskedflag,(iy + mygfxflags)
	jr z,gs16masked_exit
	res gs16maskedflag,(iy + mygfxflags)
	jr gs16masked_L3
gs16masked_exit:
	ret

;sprites currently arranged down, up, right, left w/ animation 1 followed by animation 2	
#include "charsprite.inc"
